package guru.stefma.androidartifacts

import com.android.build.gradle.api.LibraryVariant
import org.gradle.api.Project
import org.gradle.api.plugins.JavaPluginConvention
import org.gradle.api.publish.maven.MavenArtifact
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.tasks.TaskContainer

/**
 * Creates a new [MavenArtifact] by putting the generated `aar` file path into it
 * and declare the [MavenArtifact.builtBy] by the generated `assemble$VariantName`
 */
internal fun MavenPublication.addAarArtifact(
        project: Project,
        variantName: String
) {
    artifact("${project.buildDir}/outputs/aar/${variantName.aarFileName(project.name)}") {
        it.builtBy(project.tasks.getByName(variantName.aarAssembleTaskName))
    }
}

/**
 * Creates a new [MavenArtifact] by putting the [TaskContainer.createAndroidArtifactsSourcesTask] into it.
 */
internal fun MavenPublication.addAndroidSourcesArtifact(
        project: Project,
        variant: LibraryVariant
) {
    artifact(project.tasks.createAndroidArtifactsSourcesTask(variant)) {
        it.classifier = "sources"
    }
}

/**
 * Creates a new [MavenArtifact] by putting the [TaskContainer.createJavaArtifactsSourcesTask] into it.
 */
internal fun MavenPublication.addJavaSourcesArtifact(project: Project) {
    val javaConvention = project.convention.getPlugin(JavaPluginConvention::class.java)
    artifact(project.tasks.createJavaArtifactsSourcesTask(javaConvention)) {
        it.classifier = "sources"
    }
}

/**
 * Creates a new [MavenArtifact] by putting the [TaskContainer.createAndroidArtifactsJavadocTask] into it.
 */
internal fun MavenPublication.addAndroidJavadocArtifact(
        project: Project,
        variant: LibraryVariant
) {
    artifact(project.tasks.createAndroidArtifactsJavadocTask(project, variant)) {
        it.classifier = "javadoc"
    }
}

/**
 * Creates a new [MavenArtifact] by putting the [TaskContainer.createJavaArtifactsJavadocTask] into it.
 */
internal fun MavenPublication.addJavaJavadocArtifact(project: Project) {
    artifact(project.tasks.createJavaArtifactsJavadocTask()) {
        it.classifier = "javadoc"
    }
}

/**
 * Creates a new [MavenArtifact] by putting the [TaskContainer.createAndroidArtifactsDokkaTask] into it.
 */
internal fun MavenPublication.addAndroidDokkaArtifact(
        project: Project,
        variant: LibraryVariant
) {
    artifact(project.tasks.createAndroidArtifactsDokkaTask(variant.name)) {
        it.classifier = "kdoc"
    }
}

/**
 * Creates a new [MavenArtifact] by putting the [TaskContainer.createJavaArtifactsDokkaTask] into it.
 */
internal fun MavenPublication.addJavaDokkaArtifact(project: Project) {
    artifact(project.tasks.createJavaArtifactsDokkaTask()) {
        it.classifier = "kdoc"
    }
}

/**
 * Setup the "metadata" for this [MavenPublication]. Combines existing information from the [project] (like
 * [Project.getVersion] and [Project.getGroup]) with information defined in [extension]. All the information is used to
 * generate the pom file
 */
internal fun MavenPublication.setupMetadata(
        project: Project,
        extension: ArtifactsExtension
) {
    version = project.version as String
    artifactId = extension.artifactId
    groupId = project.group as String

    if (GradleVersionComparator(project.gradle.gradleVersion).betterThan("4.7")) {
        pom.name.set(extension.name ?: project.name)
        pom.description.set(extension.description ?: project.description)
        pom.url.set(extension.url)

        // TODO: Remove we in 2.0.0
        // license is deprecated
        extension.licenseSpec?.let { license ->
            pom.licenses {
                it.license {
                    it.name.set(license.name)
                    it.url.set(license.url)
                    it.comments.set(license.comments)
                    it.distribution.set(license.distribution)
                }
            }
        }
    } else {
        pom.withXml {
            it.asNode().appendNode("name", extension.name ?: project.name)
            val desc = extension.description ?: project.description ?: "-"
            if (desc != "-") {
                it.asNode().appendNode("description", desc)
            }
            extension.url?.let { url -> it.asNode().appendNode("url", url) }
        }
    }
}

/**
 * Creates the aar file name based on **this** [variantName].
 *
 * The variant name is either something simple like `debug` or `release or something more complex
 * like `flavorDebug` or `paidRelease`.
 *
 * @return a valid aar name which will be generated by the `assemble$variantName` task.
 */
private fun String.aarFileName(baseName: String): String {
    val variantNames = split(Regex("(?<!^)(?=[A-Z])"))
    return buildString {
        append(baseName)
        variantNames.forEach { append("-${it.toLowerCase()}") }
        append(".aar")
    }
}

/**
 * Creates the `assemble` task name for **this** [variantName].
 *
 * The APG (Android Gradle Plugin) creates for each **variantName**  a resp. `assemble$VariantName` tasks.
 * This will returned here.
 */
private val String.aarAssembleTaskName
    get() = "assemble${this.capitalize()}"